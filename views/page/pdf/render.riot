<page-pdf-render>
  <div each={ (page, i) in state.pages } class="rounded pdf mx-auto bg-white border-secondary my-3" style={ `width:${page.port.width}px;height:${page.port.height}px` }>
    <div each={ (field, i) in props.page.get(`data.fields.${i}`) } class="pdf-field rounded" id={ field.id } data-x={ field.left } data-y={ field.top } style={ `height:${field.height}%; width:${field.width}%; top:${field.top}%; left:${field.left}%;` }>
      <div class="pdf-field-inner">
        <hbs if={ field.field === 'custom' } template={ field.view || '' } data={ props.current ? props.current.toJSON() : state.test ? state.test.toJSON() : {} } />
        <pdf-field if={ field.field !== 'custom' } item={ props.current || state.test } field={ field } get-field={ getField } fields={ props.context.fields } />
      </div>
    </div>
    <canvas class="page-canvas" style={ `width:${page.port.width}px;height:${page.port.height}px` } />
  </div>

  <script>
    // require base class
    import * as pdfJs from 'pdfjs-dist';
    import dotProp from 'dot-prop';
    import interact from 'interactjs';
    import PerfectScrollbar from 'perfect-scrollbar';
    import { v4 as uuid } from 'uuid';

    // set worker
    pdfJs.GlobalWorkerOptions.workerSrc = '/public/assets/vendor/pdf.worker.js';

    // import field
    import pdfField from './field';

    // export default
    export default class PagePdfView {


      // ////////////////////////////////////////////////////////////////////////////
      //
      // RIOT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * static get components
       */
      static get components() {
        // return grid
        return {
          pdfField,
        };
      }

      /**
       * on before mount
       */
      onBeforeMount(...args) {
        // bind
        this.init = this.init.bind(this);
        this.getField = this.getField.bind(this);

        // set force update
        this.scheduleUpdate = () => {
          // update
          this.update();
        };
        this.scheduleDelayedUpdate = () => {
          // delay
          setTimeout(() => this.update(), 1000);
        };
      }

      /**
       * on mounted
       *
       * @param {Array} args
       */
      onMounted(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // init
        this.init();

        // where
        this.props.page.on('reload', this.scheduleUpdate);
        this.props.page.on('data.pdf', this.scheduleDelayedUpdate);
        this.props.page.on('data.model', this.init);
        this.props.page.on('data.image.images', this.scheduleUpdate);

        // on scroll
        $(document).on('scroll', this.onScroll);
      }

      /**
       * on mounted
       *
       * @param {Array} args
       */
      onBeforeUnmount(...args) {
        // where
        this.props.page.removeListener('reload', this.scheduleUpdate);
        this.props.page.removeListener('data.pdf', this.scheduleDelayedUpdate);
        this.props.page.removeListener('data.model', this.init);
        this.props.page.removeListener('data.image.images', this.scheduleUpdate);

        // on scroll
        $(document).off('scroll', this.onScroll);
      }

      /**
       * should update
       */
      shouldUpdate() {
        // check updating
        return !this.__canUpdate;
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // EVENT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * get props
       */
      getProps() {
        // clone
        const newProps = { ...(this.props) };

        // delete
        delete newProps.ref;
        delete newProps.type;
        delete newProps.item;
        delete newProps.view;
        delete newProps.class;
        delete newProps.struct;
        delete newProps.onItem;

        // return
        return newProps;
      }

      /**
       * get field
       */
      getField({ type }) {
        // return field
        return this.props.fields.find((f) => f.type === type);
      }

      /**
       * get field
       */
      getFormField({ field }) {
        // return field
        return this.props.context.fields.find((f) => f.uuid === field);
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // Init Methods
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * init
       */
      async init() {
        // loading
        const pdfUrl = this.props.page.get('data.pdf.url');

        // check task
        if (!this.task && pdfUrl) {
          // loading pdf
          this.loading('pdf', true);

          // set task
          this.task = pdfJs.getDocument(pdfUrl.replace('storage.googleapis.com/', ''));

          // get pdf
          const pdf = await this.task.promise;

          // set pages
          const pages = [];

          // loop
          for (let page = 0; page < pdf._pdfInfo.numPages; page++) {
            // actual page
            const actualPage = {
              pdf  : await pdf.getPage(page + 1),
            };
            actualPage.port = actualPage.pdf.getViewport({
              scale : 1.5,
            });

            // get pages
            pages.push(actualPage);
          }
          
          // update
          this.update({
            pdf,
            pages,
          });
          
          // loop pages
          this.$$('.page-canvas').forEach((item, i) => {
            // set values
            item.width = pages[i].port.width;
            item.height = pages[i].port.height;

            // render
            pages[i].pdf.render({
              viewport      : pages[i].port,
              canvasContext : item.getContext('2d'),
            });
          });
          
          // done
          this.loading('pdf', false);
        }

        // timeout
        setTimeout(() => {
          // generate event
          $(document).trigger('loaded');
        }, 2000);
      }

      /**
       * ref
       */
      ref(name) {
        // set refs
        if (!this.refs) this.refs = {};

        // return ref function
        return (that) => {
          // set ref
          this.refs[name] = that;
        };
      }

      /**
       * set loading
       */
      loading(type, way) {
        // set loading
        if (!this.__loading) this.__loading = new Map();

        // check loading
        if (!type) return !!Array.from(this.__loading.values()).find((v) => v);
        if (typeof way === 'undefined') return !!this.__loading.get(type);

        // set loading
        this.__loading.set(type, way);
        this.update();
      }
    }
  </script>

  <style>
    .pdf {
      margin   : auto;
      position : relative;
    }

    .pdf-field {
      top      : 0;
      left     : 0;
      z-index  : 100;
      position : absolute;
    }

    .pdf-field .pdf-field-inner {
      width    : 100%;
      height   : 100%;
      overflow : hidden;
    }
  </style>
</page-pdf-render>